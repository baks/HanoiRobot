{"version":3,"sources":["..\\Script.fsx"],"names":[],"mappings":"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","file":"Script.js","sourcesContent":["ï»¿#r \"node_modules/fable-core/Fable.Core.dll\"\r\n \r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\n \r\ntype Message = { ``type``:int; body:Body option } \r\nand Body = { bodyPart:string; value:float }\r\n \r\ntype RobotResponse = { ``type``:int; body:RobotResponseBody option } \r\nand RobotResponseBody = { bodyPart:string; currentValue:float; towerNumber:int; diskNumber:int; state:int[][] }\r\n \r\ntype Side =\r\n    | Left\r\n    | Right\r\n \r\ntype BodyPart =\r\n    | Arm\r\n    | Forearm\r\n    | Hand\r\n \r\nlet robotBodyPartToString robotBodyPart  =\r\n    match robotBodyPart with\r\n    | (Right, Arm) -> \"rightArm\"\r\n    | (Right, Forearm) -> \"rightForearm\"\r\n    | (Right, BodyPart.Hand) -> \"rightHand\"\r\n    | (Left, Arm) -> \"leftArm\"\r\n    | (Left, Forearm) -> \"leftForearm\"\r\n    | (Left, BodyPart.Hand) -> \"leftHand\"\r\n \r\nlet createRobotBodyPartFromString (bodyPart) =\r\n    match bodyPart with\r\n    | \"rightArm\" -> (Right,Arm)\r\n    | \"rightForearm\" -> (Right,Forearm)\r\n    | \"rightHand\" -> (Right,BodyPart.Hand)\r\n    | \"leftArm\" -> (Left,Arm)\r\n    | \"leftForearm\" -> (Left,Forearm)\r\n    | \"leftHand\" -> (Left,BodyPart.Hand)\r\n \r\ntype RobotCommand = \r\n    | Connect \r\n    | Activate \r\n    | Move of RobotBodyPart * float \r\n    | Hand of RobotBodyPart  \r\n \r\n    member self.ToMessageData() =\r\n        match self with\r\n        | Connect -> (0,None)\r\n        | Activate -> (1,None)\r\n        | Move (part,value) -> (2,Some { bodyPart = robotBodyPartToString part; value = value})\r\n        | Hand part -> (3,Some { bodyPart = robotBodyPartToString part; value = 0.0})\r\n \r\nand RobotBodyPart = Side * BodyPart\r\n \r\ntype Disk = \r\n    | Disk1\r\n    | Disk2 \r\n    | Disk3\r\n \r\n    static member Create(number) =\r\n        match number with\r\n        | 0 -> Disk1\r\n        | 1 -> Disk2\r\n        | 2 -> Disk3\r\n \r\ntype Tower =\r\n    | Tower1\r\n    | Tower2\r\n    | Tower3\r\n \r\n    static member Create(number) =\r\n        match number with\r\n        | 0 -> Tower1\r\n        | 1 -> Tower2\r\n        | 2 -> Tower3\r\n \r\ntype MoveDetails = { BodyPart : RobotBodyPart; CurrentValue : float }\r\n \r\ntype HanoiState = { Tower1 : Disk list; Tower2: Disk list; Tower3: Disk list }\r\n    with \r\n        static member Create(arrayState:int[][]) =\r\n            let tower1 = arrayState.[0]\r\n            let tower2 = arrayState.[1]\r\n            let tower3 = arrayState.[2]\r\n            let createDisks x = Array.map Disk.Create x |> List.ofArray\r\n            { Tower1 = tower1 |> createDisks; Tower2 = tower2 |> createDisks; Tower3 = tower3 |> createDisks }\r\n \r\ntype RobotReaction = \r\n    | Connected \r\n    | Activated \r\n    | Moved of MoveDetails\r\n    | LimitReached of RobotResponse\r\n    | HandOpened \r\n    | HandClosed \r\n    | Disk \r\n    | DiskEnter of Disk\r\n    | DiskLeave of Disk\r\n    | Hanoi of HanoiState\r\n    | TowerEnter of Tower\r\n    | TowerLeave of Tower\r\n    | InvalidMessage \r\n    | UnknownBodyPart\r\n \r\n    static member FromMessage (x:RobotResponse) =\r\n        match x.``type`` with\r\n        | 0 -> Connected\r\n        | 1 -> Activated\r\n        | 2 -> Moved { BodyPart = createRobotBodyPartFromString (x.body.Value.bodyPart); CurrentValue = x.body.Value.currentValue }\r\n        | 3 -> LimitReached x\r\n        | 4 -> HandOpened\r\n        | 5 -> HandClosed\r\n        | 6 -> Disk\r\n        | 7 -> DiskEnter (Disk.Create x.body.Value.diskNumber)\r\n        | 8 -> DiskLeave (Disk.Create x.body.Value.diskNumber)\r\n        | 9 -> Hanoi (HanoiState.Create x.body.Value.state)\r\n        | 16 -> TowerEnter (Tower.Create x.body.Value.towerNumber)\r\n        | 17 -> TowerLeave (Tower.Create x.body.Value.towerNumber)\r\n        | 18 -> InvalidMessage\r\n        | 19 -> UnknownBodyPart\r\n \r\nlet robotEvent = new Event<_>()\r\nlet robotPartsEvent = new Event<_>()\r\n \r\nlet mutable i = 0\r\nlet listenToRobot (me:MessageEvent) =\r\n    if i < 1000 then\r\n        let msg = JS.JSON.parse (me.data :?> string)\r\n        let tp : RobotResponse = msg |> unbox\r\n        printfn \"%A\" (msg)\r\n        robotEvent.Trigger (RobotReaction.FromMessage tp)\r\n        \r\n        //function looks the same when comparing them by string\r\n        robotPartsEvent.Trigger (RobotReaction.FromMessage tp)\r\n        i <- i + 1\r\n        obj()\r\n    else\r\n        obj()\r\n \r\nlet buildMessage (command:RobotCommand) =\r\n    let (t,b) = command.ToMessageData()\r\n    { ``type`` = t; Message.body = b }\r\n    |> JS.JSON.stringify\r\n \r\nlet sendMessageToRobot (iframe:HTMLIFrameElement) (port:MessagePort option) commandMessage =\r\n    let message = buildMessage commandMessage\r\n    let ports = match port with | Some x -> [|x|] | None -> [||]\r\n    iframe.contentWindow.postMessage (message, \"*\", ports)\r\n \r\nlet cover = document.getElementById \"cover\" :?> HTMLIFrameElement\r\nlet messageChannel = MessageChannel.Create()\r\n \r\nlet executeCommand = sendMessageToRobot cover None\r\n \r\nlet moved = function | Moved _ -> true | _ -> false\r\nlet onlyHanoi = function | Hanoi _ -> true | _ -> false\r\nlet onlyDiskEnter = function | DiskEnter _ -> true | _ -> false\r\nlet onlyLimitReached = function | LimitReached _ -> true | _ -> false\r\nlet onlyDisk = function | Disk -> true | _ -> false\r\nlet onlyTowerEnter x = function | TowerEnter y when x = y -> true | _ -> false\r\n \r\n//\r\n//let initialState : (float option) [] =\r\n//    [|\r\n//        None; None; None; None; None; None\r\n//    |]\r\n \r\n \r\nlet initialState : (float option) [] =\r\n    [|\r\n        Some 0.0; Some 0.0; Some 0.0; Some 0.0; Some 0.0; Some 0.0\r\n    |]\r\n \r\nlet bodyPartToIdx = function\r\n    | (Right,Arm) -> 0\r\n    | (Right,Forearm) -> 1\r\n    | (Right,BodyPart.Hand) -> 2\r\n    | (Left,Arm) -> 3\r\n    | (Left,Forearm) -> 4\r\n    | (Left,BodyPart.Hand) -> 5\r\n \r\n//let initialRobotState : System.Collections.Generic.IDictionary<BodyPart, float option> = \r\n//    dict [ (RightArm, None); (RightForearm, None); (RightHand, None); (LeftArm, None); (LeftForearm, None); (LeftHand, None) ]\r\n \r\nlet only x =\r\n    robotEvent.Publish\r\n    |> Observable.filter x\r\n \r\nlet tower1Pos = [-19.0;59.0;20.0]\r\nlet tower2Pos = [-18.0;6.0;21.0]\r\n \r\nlet rightRobotParts side =\r\n    only moved\r\n    |> Observable.split (\r\n        function\r\n        | Moved { BodyPart = (side,Arm) } as arg ->  Choice1Of2 arg\r\n        | _ as arg -> Choice2Of2 arg)\r\n    ||> (fun arm rest -> \r\n        let forearm, hand = \r\n            rest \r\n            |> Observable.split (\r\n                function \r\n                | Moved { BodyPart = (side,Forearm) } as arg -> Choice1Of2 arg\r\n                | _ as arg -> Choice2Of2 arg)\r\n \r\n        (arm, forearm, hand))\r\n \r\nlet robotState state =\r\n    only moved\r\n    |> Observable.scan (fun (previousState:(float option) []) (Moved moveDetails) -> \r\n        previousState.[bodyPartToIdx moveDetails.BodyPart] <- Some moveDetails.CurrentValue\r\n        previousState) state\r\n \r\nlet hanoiState() =\r\n    robotEvent.Publish\r\n    |> Observable.filter onlyHanoi\r\n    |> Observable.scan (fun previousHanoiState (Hanoi state) ->\r\n        state\r\n        ) { Tower1 = [Disk3;Disk2;Disk1]; Tower2 = List.empty; Tower3 = List.empty }\r\n \r\n \r\nlet moveBodyPart current target bodyPart =\r\n    if current <> target then\r\n        let moveFactor = 1.0\r\n        let moveValue = if current < target then 1.0 else -1.0\r\n        executeCommand (Move (bodyPart, moveFactor * moveValue))\r\n \r\nlet moveBodyPartTo side (targetPos:float list) (state:(float option)[]) =\r\n    let arm,forearm,hand = rightRobotParts side\r\n \r\n    let armSubscriber =\r\n        arm\r\n        |> Observable.subscribe (function\r\n            | (Moved moveDetails) -> moveBodyPart moveDetails.CurrentValue targetPos.[0] (side,Arm)\r\n            | _ -> ())\r\n \r\n    let forearmSubscriber =\r\n        forearm\r\n        |> Observable.subscribe (function\r\n            | (Moved moveDetails) -> moveBodyPart moveDetails.CurrentValue targetPos.[1] (side,Forearm)\r\n            | _ -> ())\r\n \r\n    let handSubscriber =\r\n        hand\r\n        |> Observable.subscribe (function\r\n            | (Moved moveDetails) -> moveBodyPart moveDetails.CurrentValue targetPos.[2] (side,BodyPart.Hand)\r\n            | _ -> ())\r\n \r\n    let (Some currentArm) = state.[bodyPartToIdx (side,Arm)]\r\n    let (Some currentForearm) = state.[bodyPartToIdx (side,Forearm)]\r\n    let (Some currentHand) = state.[bodyPartToIdx (side,BodyPart.Hand)]\r\n    moveBodyPart currentArm targetPos.[0] (side, Arm)\r\n    moveBodyPart currentForearm targetPos.[1] (side, Forearm)\r\n    moveBodyPart currentHand targetPos.[2] (side, BodyPart.Hand)\r\n \r\n    { \r\n    new System.IDisposable with\r\n        member x.Dispose() =\r\n            armSubscriber.Dispose()\r\n            forearmSubscriber.Dispose()\r\n            handSubscriber.Dispose() \r\n    }\r\n \r\nlet pickDisk side =\r\n    executeCommand (RobotCommand.Hand (side, BodyPart.Hand))\r\n \r\nlet dropDisk side =\r\n    executeCommand (RobotCommand.Hand (side, BodyPart.Hand))\r\n    \r\n \r\nlet move state source target = \r\n    async {\r\n        match source,target with\r\n        | Tower1,Tower2 -> \r\n            let subscriber = moveBodyPartTo Right tower1Pos state\r\n            \r\n            let mutable completed = false\r\n \r\n            let pickDiskSubscriber = \r\n                only (function | DiskEnter _ -> true | _ -> false)\r\n                |> Observable.subscribe (fun _ -> completed <- true)\r\n \r\n            while completed = false do\r\n                do! Async.Sleep 200\r\n \r\n            subscriber.Dispose()\r\n            pickDiskSubscriber.Dispose()\r\n \r\n            pickDisk Right\r\n \r\n            do! Async.Sleep 200\r\n \r\n            state.[0] <- Some tower1Pos.[0]\r\n            state.[1] <- Some tower1Pos.[1]\r\n            state.[2] <- Some tower1Pos.[2]\r\n \r\n            let moveToTargetSubscriber = moveBodyPartTo Right tower2Pos state\r\n \r\n            completed <- false\r\n \r\n            let dropDiskSubscriber =\r\n                only (function | TowerEnter target -> true | _ -> false)\r\n                |> Observable.subscribe(fun x -> completed <- true)\r\n \r\n            while completed = false do\r\n                do! Async.Sleep 200\r\n \r\n            moveToTargetSubscriber.Dispose()\r\n            dropDiskSubscriber.Dispose()\r\n            do! Async.Sleep 200\r\n            dropDisk Right\r\n            state.[0] <- Some tower2Pos.[0]\r\n            state.[1] <- Some tower2Pos.[1]\r\n            state.[2] <- Some tower2Pos.[2]\r\n \r\n            return state\r\n        | _ -> return state\r\n    }\r\n \r\nlet rec hanoi state n (source:Tower) (target:Tower) = \r\n    async {\r\n        if n > 0 then\r\n            let! state = hanoi state (n-1) source target\r\n \r\n            let! state = move state source Tower2\r\n            return state\r\n            //do! hanoi state (n-1) target source\r\n \r\n            //do! move state Tower2 target\r\n \r\n            //do! hanoi state (n-1) source target\r\n        else\r\n            return state\r\n    }\r\n \r\nlet startRobotAgent() =\r\n    sendMessageToRobot cover (Some messageChannel.port2) Connect\r\n    \r\n    messageChannel.port1.onmessage <- System.Func<MessageEvent,obj>(listenToRobot)\r\n \r\n    robotEvent.Publish\r\n    |> Observable.filter (function | Connected -> true |  _ -> false)\r\n    |> Observable.add (fun x ->\r\n \r\n        executeCommand Activate\r\n \r\n        robotEvent.Publish\r\n        |> Observable.filter (function | Activated -> true | _ -> false)\r\n        |> Observable.add (fun x -> hanoi initialState 3 Tower1 Tower3 |> Async.Ignore |> Async.StartImmediate)\r\n    )\r\n \r\n \r\ncover.addEventListener(\"load\", unbox startRobotAgent)"]}